<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ground Scour Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header>
    <h1>Ground Scour Map</h1>
    <p>Auto-built from Sentinel pre/post windows.</p>
  </header>
  <main>
    <div id="map"></div>
    <div id="legend"></div>
    <section id="scoring-doc" class="panel">
      <h2>Scoring Overview</h2>
      <p class="loading">Loading scoring metadata…</p>
    </section>
  </main>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const mapContainer = document.getElementById('map');

    const australiaBounds = L.latLngBounds([-44.0, 112.0], [-10.0, 154.0]);
    let combinedBounds = L.latLngBounds(
      australiaBounds.getSouthWest(),
      australiaBounds.getNorthEast()
    );
    let stormEventCount = 0;

    const map = L.map(mapContainer);
    map.fitBounds(combinedBounds);

    const australianBasemap = L.tileLayer(
      'https://services.ga.gov.au/gis/rest/services/NationalMap_Colour_Topography/MapServer/tile/{z}/{y}/{x}',
      {
        maxZoom: 20,
        attribution: 'Topographic Base Map © Geoscience Australia'
      }
    );

    const osmBasemap = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    });

    australianBasemap.addTo(map);

    australianBasemap.on('tileerror', () => {
      map.removeLayer(australianBasemap);
      if (!map.hasLayer(osmBasemap)) {
        osmBasemap.addTo(map);
      }
    });

    L.control.layers(
      {
        'Australian Topography': australianBasemap,
        'OpenStreetMap': osmBasemap
      },
      null,
      { position: 'topright' }
    ).addTo(map);

    const stormStrip = document.createElement('div');
    stormStrip.id = 'storm-strip';
    stormStrip.className = 'storm-strip hidden';
    stormStrip.setAttribute('aria-live', 'polite');
    mapContainer.appendChild(stormStrip);

    function createIcon(svgMarkup) {
      return `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(svgMarkup)}`;
    }

    const hazardIconSources = {
      tornado: createIcon(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" role="img" aria-hidden="true"><defs><linearGradient id="twist" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#f94144"/><stop offset="1" stop-color="#f3722c"/></linearGradient></defs><rect width="48" height="48" rx="14" fill="url(#twist)"/><path d="M10 12h28M14 19h20M12 26h24M18 32h12M21 37h6" stroke="#fff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>`
      ),
      hail: createIcon(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" role="img" aria-hidden="true"><rect width="48" height="48" rx="14" fill="#14213d"/><g stroke="#e0fbfc" stroke-width="3" stroke-linecap="round"><path d="M14 18c0-6 6-10 10-10s10 4 10 10" fill="none"/><line x1="12" y1="24" x2="12" y2="24"/><line x1="20" y1="32" x2="20" y2="32"/><line x1="28" y1="26" x2="28" y2="26"/><line x1="36" y1="34" x2="36" y2="34"/></g></svg>`
      ),
      wind: createIcon(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" role="img" aria-hidden="true"><rect width="48" height="48" rx="14" fill="#264653"/><path d="M12 20h16a4 4 0 100-8M16 28h20a5 5 0 110 10" fill="none" stroke="#f1faee" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></svg>`
      ),
      rainfall: createIcon(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" role="img" aria-hidden="true"><rect width="48" height="48" rx="14" fill="#1d3557"/><path d="M16 20a8 8 0 0116 0h2a6 6 0 110 12H14a6 6 0 010-12h2z" fill="#f8f9fa"/><g fill="#457b9d"><path d="M18 36l-2.5 6h5z"/><path d="M26 36l-2.5 6h5z"/><path d="M34 36l-2.5 6h5z"/></g></svg>`
      ),
      flood: createIcon(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" role="img" aria-hidden="true"><rect width="48" height="48" rx="14" fill="#0b7285"/><path d="M12 24c4 0 4-4 8-4s4 4 8 4 4-4 8-4 4 4 8 4" fill="none" stroke="#e0fbfc" stroke-width="3" stroke-linecap="round"/><path d="M12 32c4 0 4-4 8-4s4 4 8 4 4-4 8-4 4 4 8 4" fill="none" stroke="#e0fbfc" stroke-width="3" stroke-linecap="round"/></svg>`
      ),
      default: createIcon(
        `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" role="img" aria-hidden="true"><rect width="48" height="48" rx="14" fill="#3a0ca3"/><path d="M18 20a8 8 0 0116 0h2a6 6 0 010 12H14a6 6 0 010-12h4z" fill="#fafafa"/><path d="M14 34h20" stroke="#f72585" stroke-width="3" stroke-linecap="round"/></svg>`
      )
    };

    function showEmptyState(message) {
      let banner = document.querySelector('#map .map-empty');
      if (!banner) {
        banner = document.createElement('div');
        banner.className = 'map-empty';
        mapContainer.appendChild(banner);
      }
      banner.textContent = message;
    }

    function clearEmptyState() {
      const banner = document.querySelector('#map .map-empty');
      if (banner) {
        banner.remove();
      }
    }

    const colors = {
      0: '#f7fbff',
      1: '#c6dbef',
      2: '#9ecae1',
      3: '#6baed6',
      4: '#3182bd',
      5: '#08519c'
    };

    function style(feature) {
      const gss = feature.properties?.gss ?? 0;
      return {
        color: '#333',
        weight: 1,
        fillColor: colors[gss] || '#cccccc',
        fillOpacity: 0.6
      };
    }

    fetch('data/changes.geojson')
      .then(resp => {
        if (!resp.ok) {
          throw new Error(`Failed to fetch changes.geojson: ${resp.status}`);
        }
        return resp.json();
      })
      .then(data => {
        const features = Array.isArray(data.features) ? data.features : [];
        if (!features.length) {
          showEmptyState('No change polygons were published for the latest run.');
          buildLegend();
          return;
        }
        clearEmptyState();
        const layer = L.geoJSON(data, { style }).addTo(map);
        const bounds = layer.getBounds();
        if (bounds.isValid()) {
          fitToBounds(bounds);
        }
        buildLegend();
      })
      .catch(err => {
        console.error('Failed to load GeoJSON', err);
        showEmptyState('Change layer unavailable. Latest run did not produce any map features.');
        buildLegend();
      });

    function buildLegend() {
      const legend = document.getElementById('legend');
      legend.innerHTML = '<h3>Ground-Scour Score</h3>';
      for (let i = 0; i <= 5; i++) {
        const row = document.createElement('div');
        row.className = 'legend-row';
        row.innerHTML = `<span class="swatch" style="background:${colors[i]}"></span> GSS ${i}`;
        legend.appendChild(row);
      }
      if (stormEventCount > 0) {
        const divider = document.createElement('hr');
        divider.className = 'legend-divider';
        legend.appendChild(divider);

        const stormRow = document.createElement('div');
        stormRow.className = 'legend-row legend-row--storms';
        stormRow.innerHTML = `
          <span class="storm-marker"></span>
          Storm reports (${stormEventCount})
        `;
        legend.appendChild(stormRow);
      }
    }

    function fitToBounds(newBounds) {
      if (!newBounds || !newBounds.isValid()) return;
      combinedBounds.extend(newBounds);
      map.fitBounds(combinedBounds.pad(0.05));
    }

    function getHazardIcon(hazardName) {
      if (!hazardName) return hazardIconSources.default;
      const key = hazardName.toLowerCase();
      if (key.includes('tornado')) return hazardIconSources.tornado;
      if (key.includes('hail')) return hazardIconSources.hail;
      if (key.includes('wind')) return hazardIconSources.wind;
      if (key.includes('flood')) return hazardIconSources.flood;
      if (key.includes('rain') || key.includes('storm')) {
        return hazardIconSources.rainfall;
      }
      return hazardIconSources.default;
    }

    function renderStormStrip(features) {
      if (!stormStrip) return;
      stormStrip.innerHTML = '';

      if (!Array.isArray(features) || !features.length) {
        stormStrip.classList.add('hidden');
        mapContainer.classList.remove('has-storm-strip');
        return;
      }

      const sorted = [...features].sort((a, b) => {
        const timeA = new Date(a.properties?.event_time_utc || 0).getTime();
        const timeB = new Date(b.properties?.event_time_utc || 0).getTime();
        return timeB - timeA;
      });

      for (const feature of sorted) {
        const props = feature.properties || {};
        const hazardLabel = props.hazard || 'Storm report';
        const timestamp = props.event_time_utc
          ? new Date(props.event_time_utc).toLocaleString()
          : '';
        const details = props.details || '';

        const card = document.createElement('article');
        card.className = 'storm-card';
        card.innerHTML = `
          <img src="${getHazardIcon(hazardLabel)}" alt="${hazardLabel}" />
          <div class="storm-card__copy">
            <p class="storm-card__hazard">${hazardLabel}</p>
            ${timestamp ? `<p class="storm-card__time">${timestamp}</p>` : ''}
            ${details ? `<p class="storm-card__details">${details}</p>` : ''}
          </div>
        `;

        if (details) {
          card.title = `${hazardLabel}${timestamp ? ` — ${timestamp}` : ''}\n${details}`;
        } else if (timestamp) {
          card.title = `${hazardLabel} — ${timestamp}`;
        }

        stormStrip.appendChild(card);
      }

      stormStrip.classList.remove('hidden');
      mapContainer.classList.add('has-storm-strip');
    }

    fetch('data/storm_events.geojson')
      .then(resp => {
        if (!resp.ok) {
          throw new Error(`Failed to fetch storm_events.geojson: ${resp.status}`);
        }
        return resp.json();
      })
      .then(data => {
        const features = Array.isArray(data.features) ? data.features : [];
        if (!features.length) {
          stormEventCount = 0;
          renderStormStrip([]);
          buildLegend();
          return;
        }

        stormEventCount = features.length;
        renderStormStrip(features);
        const layer = L.geoJSON(data, {
          pointToLayer: (_feature, latlng) =>
            L.circleMarker(latlng, {
              radius: 6,
              fillColor: '#f94144',
              color: '#a4161a',
              weight: 1,
              opacity: 1,
              fillOpacity: 0.85
            }),
          onEachFeature: (feature, layer) => {
            const props = feature.properties || {};
            const title = props.hazard || 'Storm report';
            const details = props.details ? `<p>${props.details}</p>` : '';
            const timestamp = props.event_time_utc
              ? new Date(props.event_time_utc).toLocaleString()
              : null;
            layer.bindPopup(`
              <strong>${title}</strong>
              ${timestamp ? `<p>${timestamp}</p>` : ''}
              ${details}
            `);

            const labelParts = [];
            if (props.hazard) {
              labelParts.push(props.hazard);
            }
            if (props.event_time_utc) {
              const timeString = new Date(props.event_time_utc).toLocaleString();
              labelParts.push(timeString);
            }
            if (props.details) {
              labelParts.push(props.details);
            }

            if (labelParts.length) {
              layer.bindTooltip(labelParts.join(' • '), {
                permanent: true,
                direction: 'top',
                offset: [0, -10],
                className: 'storm-tooltip'
              });
            }
          }
        }).addTo(map);

        const bounds = layer.getBounds();
        fitToBounds(bounds);
        const banner = document.querySelector('#map .map-empty');
        if (banner && !banner.dataset.stormContext) {
          banner.dataset.stormContext = 'true';
          banner.insertAdjacentHTML(
            'beforeend',
            '<p class="map-empty-note">Recent storm reports are highlighted in red.</p>'
          );
        }
        buildLegend();
      })
      .catch(err => {
        console.warn('Storm events layer unavailable', err);
        stormEventCount = 0;
        renderStormStrip([]);
        buildLegend();
      });

    function renderScoring(metadata) {
      const container = document.getElementById('scoring-doc');
      if (!metadata || !metadata.scoring) {
        container.innerHTML = '<h2>Scoring Overview</h2><p>Scoring metadata not available.</p>';
        return;
      }

      const generated = metadata.generated_at
        ? new Date(metadata.generated_at).toLocaleString()
        : 'Unknown';

      const components = metadata.scoring.components || {};
      const componentItems = Object.entries(components)
        .map(([key, info]) => {
          const label = info.label || key;
          const weight = typeof info.weight === 'number' ? info.weight.toFixed(2) : 'n/a';
          const status = info.active === false ? ' (inactive)' : '';
          return `<li><strong>${label}</strong> — weight ${weight}${status}</li>`;
        })
        .join('');

      const sentinelComponent = components['s1_logratio'] || {};
      const sentinel1Status = sentinelComponent.active
        ? 'Sentinel-1 weighting is enabled.'
        : 'Sentinel-1 weighting is disabled.';

      const thresholds = metadata.gss?.resolved_thresholds || [];
      const thresholdList = thresholds
        .map((value, idx) => `<li>Break ${idx + 1}: ${value.toFixed(3)}</li>`)
        .join('');

      const gssCounts = metadata.gss?.counts || {};
      const countRows = Object.entries(gssCounts)
        .map(([level, count]) => `<tr><th>GSS ${level}</th><td>${count}</td></tr>`)
        .join('');

      const meanMin = metadata.polygons?.mean_score_min;
      const meanMax = metadata.polygons?.mean_score_max;
      const meanRangeText =
        meanMin != null && meanMax != null
          ? `${Number(meanMin).toFixed(3)} – ${Number(meanMax).toFixed(3)}`
          : 'n/a';

      const totalArea = metadata.polygons?.total_area_m2;
      const totalAreaText =
        typeof totalArea === 'number'
          ? `${(totalArea / 1e6).toFixed(2)} km²`
          : 'n/a';

      container.innerHTML = `
        <h2>Scoring Overview</h2>
        <p class="timestamp">Generated ${generated}</p>
        <section>
          <h3>Components</h3>
          <ul class="bullets">${componentItems || '<li>No components reported.</li>'}</ul>
          <p class="note">${sentinel1Status}</p>
        </section>
        <section>
          <h3>Thresholding</h3>
          <p>Method: <strong>${metadata.threshold?.method || 'n/a'}</strong>${
            metadata.threshold?.value != null
              ? ` (cutoff ${Number(metadata.threshold.value).toFixed(3)})`
              : ''
          }</p>
        </section>
        <section>
          <h3>Ground-Scour Score breaks</h3>
          <ul class="bullets">${thresholdList || '<li>No thresholds reported.</li>'}</ul>
          <table class="counts">
            <caption>Polygon counts by GSS</caption>
            <tbody>${countRows}</tbody>
          </table>
        </section>
        <section>
          <h3>Polygon summary</h3>
          <p>Total polygons: <strong>${metadata.polygons?.count ?? 0}</strong></p>
          <p>Total mapped area: <strong>${totalAreaText}</strong></p>
          <p>Mean score range: <strong>${meanRangeText}</strong></p>
        </section>
      `;
    }

    fetch('data/scoring.json')
      .then(resp => resp.json())
      .then(renderScoring)
      .catch(() => {
        const container = document.getElementById('scoring-doc');
        container.innerHTML = '<h2>Scoring Overview</h2><p>Scoring metadata not available.</p>';
      });
  </script>
</body>
</html>
