<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ground Scour Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header>
    <h1>Ground Scour Map</h1>
    <p>Auto-built from Sentinel pre/post windows.</p>
  </header>
  <main>
    <div id="map"></div>
    <div id="legend"></div>
    <section id="scoring-doc" class="panel">
      <h2>Scoring Overview</h2>
      <p class="loading">Loading scoring metadata…</p>
    </section>
  </main>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const DEFAULT_VIEW = { center: [-27.0, 151.5], zoom: 9 };
    const STORAGE_KEY = 'gss-map-view-state-v1';

    function readStoredState() {
      if (typeof window === 'undefined' || !window.localStorage) return null;
      try {
        const raw = window.localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : null;
      } catch (err) {
        console.warn('Failed to read stored map state', err);
        return null;
      }
    }

    function writeStoredState(state) {
      if (typeof window === 'undefined' || !window.localStorage) return;
      try {
        window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (err) {
        console.warn('Failed to persist map state', err);
      }
    }

    function arrayToBounds(boundsArray) {
      if (!Array.isArray(boundsArray) || boundsArray.length !== 2) return null;
      const [sw, ne] = boundsArray;
      if (!Array.isArray(sw) || !Array.isArray(ne) || sw.length !== 2 || ne.length !== 2) {
        return null;
      }
      return L.latLngBounds(
        L.latLng(Number(sw[0]), Number(sw[1])),
        L.latLng(Number(ne[0]), Number(ne[1]))
      );
    }

    const savedViewState = readStoredState();
    const map = L.map('map', { preferCanvas: true });

    if (savedViewState?.context === 'custom' && savedViewState?.bounds) {
      const storedBounds = arrayToBounds(savedViewState.bounds);
      if (storedBounds && storedBounds.isValid()) {
        map.fitBounds(storedBounds, { animate: false });
      } else if (savedViewState?.center && typeof savedViewState.zoom === 'number') {
        map.setView(savedViewState.center, savedViewState.zoom);
      } else {
        map.setView(DEFAULT_VIEW.center, DEFAULT_VIEW.zoom);
      }
    } else if (savedViewState?.center && typeof savedViewState.zoom === 'number') {
      map.setView(savedViewState.center, savedViewState.zoom);
    } else {
      map.setView(DEFAULT_VIEW.center, DEFAULT_VIEW.zoom);
    }

    map.createPane('track-outline');
    map.getPane('track-outline').style.zIndex = 450;
    map.getPane('track-outline').style.pointerEvents = 'none';

    let combinedBounds = null;
    let scarBounds = null;
    let trackOutlineLayer = null;
    let stormEventCount = 0;
    let isApplyingContext = false;
    let initialContextApplied = false;
    const contextButtons = {};
    let activeContext = savedViewState?.context || 'track';

    const australianBasemap = L.tileLayer(
      'https://services.ga.gov.au/gis/rest/services/NationalMap_Colour_Topography/MapServer/tile/{z}/{y}/{x}',
      {
        maxZoom: 20,
        attribution: 'Topographic Base Map © Geoscience Australia'
      }
    );

    const osmBasemap = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    });

    osmBasemap.addTo(map);

    australianBasemap.on('tileerror', () => {
      if (map.hasLayer(australianBasemap)) {
        map.removeLayer(australianBasemap);
      }
      if (!map.hasLayer(osmBasemap)) {
        osmBasemap.addTo(map);
      }
    });

    L.control.layers(
      {
        'OpenStreetMap': osmBasemap,
        'Australian Topography': australianBasemap
      },
      null,
      { position: 'topright' }
    ).addTo(map);

    const mapContainer = document.getElementById('map');

    const CONTEXT_DEFINITIONS = {
      track: {
        label: 'Track',
        description: 'Zoom to the mapped tornado scar.',
        getBounds: () => (scarBounds ? scarBounds.pad(0.08) : null),
        maxZoom: 15
      },
      neighborhood: {
        label: 'Neighborhood',
        description: 'Show nearby damage context.',
        getBounds: () => {
          if (scarBounds) {
            return scarBounds.pad(0.4);
          }
          return combinedBounds ? combinedBounds.pad(0.1) : null;
        },
        maxZoom: 13
      },
      region: {
        label: 'Region',
        description: 'Compare the scar to the wider region.',
        getBounds: () => (combinedBounds ? combinedBounds.pad(0.25) : null),
        maxZoom: 11
      }
    };

    function updateContextButtons() {
      Object.entries(contextButtons).forEach(([key, button]) => {
        const bounds = CONTEXT_DEFINITIONS[key]?.getBounds?.();
        const enabled = !!(bounds && bounds.isValid());
        button.disabled = !enabled;
        button.classList.toggle('is-active', key === activeContext && enabled);
      });
    }

    function persistViewState() {
      if (!map._loaded) return;
      const center = map.getCenter();
      const bounds = map.getBounds();
      const state = {
        context: activeContext,
        center: [Number(center.lat), Number(center.lng)],
        zoom: map.getZoom(),
        bounds: [
          [bounds.getSouthWest().lat, bounds.getSouthWest().lng],
          [bounds.getNorthEast().lat, bounds.getNorthEast().lng]
        ]
      };
      writeStoredState(state);
    }

    function refreshContextAvailability() {
      updateContextButtons();
    }

    function setActiveContext(key, { immediate = false } = {}) {
      const context = CONTEXT_DEFINITIONS[key];
      if (!context) return false;
      const bounds = context.getBounds();
      if (!bounds || !bounds.isValid()) return false;

      activeContext = key;
      updateContextButtons();

      const fitOptions = {
        animate: !immediate,
        padding: [30, 30]
      };
      if (context.maxZoom != null) {
        fitOptions.maxZoom = context.maxZoom;
      }

      isApplyingContext = true;
      map.fitBounds(bounds, fitOptions);
      return true;
    }

    function applyStoredBounds(boundsArray) {
      const storedBounds = arrayToBounds(boundsArray);
      if (!storedBounds || !storedBounds.isValid()) {
        return false;
      }
      isApplyingContext = true;
      map.fitBounds(storedBounds, { animate: false, padding: [30, 30] });
      return true;
    }

    function maybeApplyInitialView() {
      if (initialContextApplied) return;
      refreshContextAvailability();

      if (activeContext === 'custom' && savedViewState?.bounds) {
        const applied = applyStoredBounds(savedViewState.bounds);
        if (applied) {
          initialContextApplied = true;
          updateContextButtons();
          return;
        }
      }

      const preferredKey = CONTEXT_DEFINITIONS[activeContext] ? activeContext : 'track';
      const preferredApplied = setActiveContext(preferredKey, { immediate: true });
      if (preferredApplied) {
        initialContextApplied = true;
        return;
      }

      if (savedViewState?.bounds) {
        const fallbackApplied = applyStoredBounds(savedViewState.bounds);
        if (fallbackApplied) {
          activeContext = 'custom';
          initialContextApplied = true;
          updateContextButtons();
        }
      }
    }

    const contextControl = L.control({ position: 'topleft' });
    contextControl.onAdd = () => {
      const container = L.DomUtil.create('div', 'leaflet-bar context-control');
      L.DomEvent.disableClickPropagation(container);
      L.DomEvent.disableScrollPropagation(container);
      Object.entries(CONTEXT_DEFINITIONS).forEach(([key, info]) => {
        const button = L.DomUtil.create('button', 'context-button', container);
        button.type = 'button';
        button.textContent = info.label;
        button.title = info.description;
        button.disabled = true;
        button.dataset.contextKey = key;
        button.addEventListener('click', () => {
          setActiveContext(key);
        });
        contextButtons[key] = button;
      });
      return container;
    };
    contextControl.addTo(map);

    map.on('movestart', () => {
      if (!isApplyingContext) {
        activeContext = 'custom';
        updateContextButtons();
      }
    });

    map.on('moveend', () => {
      if (isApplyingContext) {
        isApplyingContext = false;
      }
      persistViewState();
    });

    let summaryData = null;
    let palette = ["#d0d0d0", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"];

    const infoControl = L.control({ position: 'topright' });
    infoControl.onAdd = function () {
      const div = L.DomUtil.create('div', 'info-control');
      L.DomEvent.disableClickPropagation(div);
      this._div = div;
      this.update();
      return div;
    };
    infoControl.update = function (data = summaryData) {
      const div = this._div;
      if (!div) return;
      if (!data || !Number(data.total)) {
        div.innerHTML = '<h3>Ground Scour</h3><p>No detections after filters.</p>';
        return;
      }
      const meanElong = data.mean_elongation != null && isFinite(data.mean_elongation)
        ? Number(data.mean_elongation).toFixed(2)
        : 'n/a';
      const bearingCluster = data.bearing_cluster_deg != null && isFinite(data.bearing_cluster_deg)
        ? `${Number(data.bearing_cluster_deg).toFixed(1)}°`
        : 'n/a';
      const rows = [];
      for (let i = 0; i <= 5; i++) {
        const count = data.per_gss?.[String(i)] ?? 0;
        rows.push(`<tr><th>GSS ${i}</th><td>${count}</td></tr>`);
      }
      div.innerHTML = `
        <h3>Ground Scour</h3>
        <p>Total polygons: <strong>${data.total}</strong></p>
        <p>Mean elongation: <strong>${meanElong}</strong></p>
        <p>Bearing cluster: <strong>${bearingCluster}</strong></p>
        <table class="info-counts">
          <tbody>${rows.join('')}</tbody>
        </table>
      `;
    };
    infoControl.addTo(map);

    function showEmptyState(message) {
      let banner = document.querySelector('#map .map-empty');
      if (!banner) {
        banner = document.createElement('div');
        banner.className = 'map-empty';
        mapContainer.appendChild(banner);
      }
      banner.textContent = message;
    }

    function clearEmptyState() {
      const banner = document.querySelector('#map .map-empty');
      if (banner) {
        banner.remove();
      }
    }

    function colorForGss(value) {
      const idx = Number.isFinite(Number(value)) ? Number(value) : 0;
      const clamped = Math.max(0, Math.min(palette.length - 1, idx));
      return palette[clamped] || '#cccccc';
    }

    function style(feature) {
      const gss = Number(feature.properties?.gss ?? 0);
      return {
        color: '#333',
        weight: 1,
        fillColor: colorForGss(gss),
        fillOpacity: 0.6
      };
    }

    function bindPopup(feature, layer) {
      const props = feature.properties || {};
      const rows = [];
      const mapping = [
        ['GSS', props.gss != null ? props.gss : '0'],
        ['Elongation', props.elongation != null ? Number(props.elongation).toFixed(2) : 'n/a'],
        ['Length', props.length_m != null ? `${Number(props.length_m).toFixed(0)} m` : 'n/a'],
        ['Width', props.width_m != null ? `${Number(props.width_m).toFixed(0)} m` : 'n/a'],
        ['Bearing', props.bearing_deg != null ? `${Number(props.bearing_deg).toFixed(1)}°` : 'n/a'],
        ['Change score', props.change_score_mean != null ? Number(props.change_score_mean).toFixed(3) : 'n/a'],
        ['ΔNDVI', props.delta_ndvi_mean != null ? Number(props.delta_ndvi_mean).toFixed(3) : 'n/a'],
        ['Δbrightness', props.delta_brightness_mean != null ? Number(props.delta_brightness_mean).toFixed(3) : 'n/a'],
        ['Area', props.area_m2 != null ? `${Number(props.area_m2).toFixed(0)} m²` : 'n/a']
      ];
      mapping.forEach(([label, value]) => {
        rows.push(`<tr><th>${label}</th><td>${value}</td></tr>`);
      });
      const explain = props.gss_explain ? `<p class="popup-explain">${props.gss_explain}</p>` : '';
      layer.bindPopup(`
        <div class="popup-content">
          <h3>GSS ${props.gss ?? 0}</h3>
          <table class="popup-table">${rows.join('')}</table>
          ${explain}
        </div>
      `);
    }

    function loadPolygons() {
      return fetch('data/changes_scored.geojson')
      .then(resp => {
        if (!resp.ok) {
          throw new Error(`Failed to fetch changes_scored.geojson: ${resp.status}`);
        }
        return resp.json();
      })
      .then(data => {
        const features = Array.isArray(data.features) ? data.features : [];
        if (!features.length) {
          showEmptyState('No detections after filters.');
          infoControl.update();
          buildLegend();
          maybeApplyInitialView();
          return;
        }
        clearEmptyState();
        const layer = L.geoJSON(data, { style, onEachFeature: bindPopup }).addTo(map);
        const bounds = layer.getBounds();
        if (bounds.isValid()) {
          scarBounds = L.latLngBounds(bounds);
          if (trackOutlineLayer) {
            trackOutlineLayer.remove();
          }
          trackOutlineLayer = L.geoJSON(data, {
            pane: 'track-outline',
            interactive: false,
            style: () => ({
              color: '#f3722c',
              weight: 2.5,
              fillOpacity: 0,
              dashArray: '8 4',
              opacity: 0.85
            })
          }).addTo(map);
          fitToBounds(bounds);
        }
        buildLegend();
        infoControl.update();
      })
      .catch(err => {
        console.error('Failed to load GeoJSON', err);
        showEmptyState('Change layer unavailable. Latest run did not produce any map features.');
        buildLegend();
        maybeApplyInitialView();
        infoControl.update();
      });
    }

    function buildLegend() {
      const legend = document.getElementById('legend');
      legend.innerHTML = '<h3>Ground-Scour Score</h3>';
      for (let i = 0; i <= 5; i++) {
        const row = document.createElement('div');
        row.className = 'legend-row';
        const count = summaryData?.per_gss?.[String(i)] ?? 0;
        row.innerHTML = `
          <span class="swatch" style="background:${colorForGss(i)}"></span>
          <span class="legend-label">GSS ${i}</span>
          <span class="legend-count">${count}</span>
        `;
        legend.appendChild(row);
      }
      if (stormEventCount > 0) {
        const divider = document.createElement('hr');
        divider.className = 'legend-divider';
        legend.appendChild(divider);

        const stormRow = document.createElement('div');
        stormRow.className = 'legend-row legend-row--storms';
        stormRow.innerHTML = `
          <span class="storm-marker"></span>
          Storm reports (${stormEventCount})
        `;
        legend.appendChild(stormRow);
      }
    }

    function renderSummary(data) {
      summaryData = data;
      if (data?.webmap_palette && Array.isArray(data.webmap_palette)) {
        const paletteArray = data.webmap_palette.filter(Boolean);
        if (paletteArray.length) {
          palette = paletteArray.slice(0, 6);
          while (palette.length < 6) {
            palette.push('#d0d0d0');
          }
        }
      }
      if (data?.title) {
        const headerTitle = document.querySelector('header h1');
        if (headerTitle) headerTitle.textContent = data.title;
      }
      if (data?.description) {
        const headerDesc = document.querySelector('header p');
        if (headerDesc) headerDesc.textContent = data.description;
      }
      infoControl.update(data);
      buildLegend();

      const container = document.getElementById('scoring-doc');
      if (!data) {
        container.innerHTML = '<h2>Summary</h2><p>Summary metadata not available.</p>';
        return;
      }

      const generated = data.generated_at
        ? new Date(data.generated_at).toLocaleString()
        : 'Unknown';
      const hash = data.config_hash || 'n/a';
      const perGssRows = [];
      for (let i = 0; i <= 5; i++) {
        const count = data.per_gss?.[String(i)] ?? 0;
        perGssRows.push(`<tr><th>GSS ${i}</th><td>${count}</td></tr>`);
      }
      const filtersList = Object.entries(data.filters || {})
        .map(([key, value]) => `<li><code>${key}</code>: ${Number(value).toFixed(3)}</li>`)
        .join('');
      const rulesList = Object.entries(data.score_rules || {})
        .map(([key, value]) => `<li><code>${key}</code>: ${Number(value).toFixed(3)}</li>`)
        .join('');
      const timestamps = data.timestamps || {};
      const started = timestamps.started ? new Date(timestamps.started).toLocaleString() : 'n/a';
      const finished = timestamps.finished ? new Date(timestamps.finished).toLocaleString() : 'n/a';

      container.innerHTML = `
        <h2>Summary</h2>
        <p class="timestamp">Generated ${generated}</p>
        <section>
          <h3>Run details</h3>
          <p>Config hash: <code>${hash}</code></p>
          <p>Started: ${started}</p>
          <p>Finished: ${finished}</p>
        </section>
        <section>
          <h3>Polygon counts</h3>
          <p>Total polygons: <strong>${data.total}</strong> (input ${data.total_input ?? 0})</p>
          <table class="counts">
            <tbody>${perGssRows.join('')}</tbody>
          </table>
        </section>
        <section>
          <h3>Filters</h3>
          <ul class="bullets">${filtersList || '<li>None reported.</li>'}</ul>
        </section>
        <section>
          <h3>Scoring rules</h3>
          <ul class="bullets">${rulesList || '<li>None reported.</li>'}</ul>
        </section>
      `;
    }

    function fitToBounds(newBounds) {
      if (!newBounds || !newBounds.isValid()) return;
      if (combinedBounds) {
        combinedBounds.extend(newBounds);
      } else {
        combinedBounds = L.latLngBounds(newBounds);
      }
      refreshContextAvailability();
      maybeApplyInitialView();
      if (initialContextApplied && activeContext !== 'custom' && !isApplyingContext) {
        setActiveContext(activeContext);
      }
    }

    fetch('data/storm_events.geojson')
      .then(resp => {
        if (!resp.ok) {
          throw new Error(`Failed to fetch storm_events.geojson: ${resp.status}`);
        }
        return resp.json();
      })
      .then(data => {
        const features = Array.isArray(data.features) ? data.features : [];
        if (!features.length) {
          return;
        }

        stormEventCount = features.length;
        const layer = L.geoJSON(data, {
          pointToLayer: (_feature, latlng) =>
            L.circleMarker(latlng, {
              radius: 6,
              fillColor: '#f94144',
              color: '#a4161a',
              weight: 1,
              opacity: 1,
              fillOpacity: 0.85
            }),
          onEachFeature: (feature, layer) => {
            const props = feature.properties || {};
            const title = props.hazard || 'Storm report';
            const details = props.details ? `<p>${props.details}</p>` : '';
            const timestamp = props.event_time_utc
              ? new Date(props.event_time_utc).toLocaleString()
              : null;
            layer.bindPopup(`
              <strong>${title}</strong>
              ${timestamp ? `<p>${timestamp}</p>` : ''}
              ${details}
            `);

            const labelParts = [];
            if (props.hazard) {
              labelParts.push(props.hazard);
            }
            if (props.event_time_utc) {
              const timeString = new Date(props.event_time_utc).toLocaleString();
              labelParts.push(timeString);
            }
            if (props.details) {
              labelParts.push(props.details);
            }

            if (labelParts.length) {
              layer.bindTooltip(labelParts.join(' • '), {
                permanent: true,
                direction: 'top',
                offset: [0, -10],
                className: 'storm-tooltip'
              });
            }
          }
        }).addTo(map);

        const bounds = layer.getBounds();
        fitToBounds(bounds);
        const banner = document.querySelector('#map .map-empty');
        if (banner && !banner.dataset.stormContext) {
          banner.dataset.stormContext = 'true';
          banner.insertAdjacentHTML(
            'beforeend',
            '<p class="map-empty-note">Recent storm reports are highlighted in red.</p>'
          );
        }
        buildLegend();
      })
      .catch(err => {
        console.warn('Storm events layer unavailable', err);
      });

    fetch('data/summary.json')
      .then(resp => {
        if (!resp.ok) {
          throw new Error(`Failed to fetch summary.json: ${resp.status}`);
        }
        return resp.json();
      })
      .then(data => {
        renderSummary(data);
      })
      .catch(err => {
        console.warn('Summary metadata not available', err);
        renderSummary(null);
      })
      .finally(() => {
        loadPolygons();
      });
  </script>
</body>
</html>
